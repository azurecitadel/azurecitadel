<html data-color-mode="auto" data-light-theme="light" data-dark-theme="dark_dimmed" prefix="og: http://ogp.me/ns#"
  lang="{{ .Language }}">

{{- partial "head.html" . -}}

<body class="width-full overflow-hidden" style="height:100vh;">
  <main class="d-flex flex-row width-full" style="height:100%; min-height:0;">
    {{- partial "sidebar.html" . -}}
  <div id="sidebar-overlay" class="sidebar-overlay"></div>

  <div class="d-flex flex-column flex-1 width-full overflow-y-auto sidebar-scroll scroll-overlay" id="main-scroll" style="min-height:0;">
      <header class="main-header container-xl px-3 px-md-6 width-full" role="banner" aria-label="Main header">
        <div class="d-flex flex-items-center" style="gap:.75rem;">
          {{- partial "breadcrumbs.html" . -}}
          <div class="header-actions">
            {{/* Series neighbors for header controls */}}
            {{- partial "series-navigation.html" . -}}
            {{ with index .Scratch.Values "prevInSeriesHeader" }}
              <a class="btn-octicon series-btn" href="{{ .Permalink }}" aria-label="Previous in series: {{ .Title }}" title="{{ .Title }}">{{- partial "octicon" (dict "icon" "chevron-left" "height" 16) -}}</a>
            {{ else }}
              <span class="btn-octicon series-btn is-disabled" aria-disabled="true" title="No previous page">{{- partial "octicon" (dict "icon" "chevron-left" "height" 16) -}}</span>
            {{ end }}
            <button id="toc-toggle" class="btn-octicon toc-btn" type="button" aria-expanded="false" aria-controls="toc-flydown" title="Table of contents">TOC</button>
            {{ with index .Scratch.Values "nextInSeriesHeader" }}
              <a class="btn-octicon series-btn" href="{{ .Permalink }}" aria-label="Next in series: {{ .Title }}" title="{{ .Title }}">{{- partial "octicon" (dict "icon" "chevron-right" "height" 16) -}}</a>
            {{ else }}
              <span class="btn-octicon series-btn is-disabled" aria-disabled="true" title="No next page">{{- partial "octicon" (dict "icon" "chevron-right" "height" 16) -}}</span>
            {{ end }}
          </div>
        </div>
      </header>
      <div id="toc-flydown" aria-hidden="true"><div class="panel container-xl px-3 px-md-6 py-2"></div></div>
      <!-- Image Lightbox Overlay -->
      <div id="image-lightbox" aria-hidden="true">
        <div class="ilb-backdrop" role="presentation"></div>
        <figure class="ilb-content" role="dialog" aria-modal="true" aria-label="Image preview">
          <div class="ilb-wrap">
            <img alt="" />
            <div class="ilb-caption" hidden></div>
          </div>
        </figure>
      </div>
      {{- block "main" . }}{{- end }}
    </div>
  </main>

</body>

<script>
  (function(){
    const STORAGE_KEY='citadel-theme-mode'; // persisted user choice
    const root=document.documentElement;
    function systemPref(){ return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark':'light'; }
    function stored(){ try{return localStorage.getItem(STORAGE_KEY);}catch(e){return null;} }
    function persist(v){ try{ localStorage.setItem(STORAGE_KEY,v);}catch(e){} }
    function apply(mode){
      const eff = mode==='dark' ? 'dark' : 'light';
      root.setAttribute('data-color-mode', eff);
      root.setAttribute('data-light-theme','light');
      root.setAttribute('data-dark-theme','dark_dimmed');
      root.classList.toggle('citadel-user-dark', eff==='dark');
      root.classList.toggle('citadel-user-light', eff==='light');
      updateButtons(eff);

      // Update theme-responsive images immediately
      const images = document.querySelectorAll('img[data-theme-responsive="true"]');
      images.forEach(img => {
        const lightSrc = img.getAttribute('data-light-src');
        const darkSrc = img.getAttribute('data-dark-src');
        if (eff === 'dark' && darkSrc) {
          img.src = darkSrc;
        } else if (eff === 'light' && lightSrc) {
          img.src = lightSrc;
        }
      });
    }
    function updateButtons(eff){
      const lightBtn=document.getElementById('theme-light');
      const darkBtn=document.getElementById('theme-dark');
      if(lightBtn){ lightBtn.classList.toggle('is-active', eff==='light'); lightBtn.setAttribute('aria-pressed', eff==='light'); }
      if(darkBtn){ darkBtn.classList.toggle('is-active', eff==='dark'); darkBtn.setAttribute('aria-pressed', eff==='dark'); }
    }
    document.addEventListener('DOMContentLoaded',function(){
      apply(stored()||systemPref());
      const btnLight=document.getElementById('theme-light');
      const btnDark=document.getElementById('theme-dark');
      if(btnLight) btnLight.addEventListener('click',()=>{ persist('light'); apply('light'); });
      if(btnDark) btnDark.addEventListener('click',()=>{ persist('dark'); apply('dark'); });
      if(window.matchMedia){
        const mq=window.matchMedia('(prefers-color-scheme: dark)');
        mq.addEventListener('change',()=>{ if(!stored()){ apply(systemPref()); } });
      }
      window.addEventListener('storage',e=>{ if(e.key===STORAGE_KEY) apply(stored()||systemPref()); });
    });
    // Fallback: delegate clicks in case DOMContentLoaded timing prevented binding
    document.addEventListener('click', function(e){
      const light = e.target.closest && e.target.closest('#theme-light');
      const dark = e.target.closest && e.target.closest('#theme-dark');
      if(light){ persist('light'); apply('light'); }
      else if(dark){ persist('dark'); apply('dark'); }
    });
  })();

  // GitHub-style theme-responsive images
  (function(){
    function updateThemeResponsiveImages() {
      const mode = document.documentElement.getAttribute('data-color-mode') || 'light';
      const images = document.querySelectorAll('img[data-theme-responsive="true"]');

      images.forEach(img => {
        const lightSrc = img.getAttribute('data-light-src');
        const darkSrc = img.getAttribute('data-dark-src');

        if (mode === 'dark' && darkSrc) {
          img.src = darkSrc;
        } else if (mode === 'light' && lightSrc) {
          img.src = lightSrc;
        }
      });

      // Also update source elements in picture tags
      const sources = document.querySelectorAll('source[data-light-src], source[data-dark-src]');
      sources.forEach(source => {
        const lightSrc = source.getAttribute('data-light-src');
        const darkSrc = source.getAttribute('data-dark-src');

        if (mode === 'dark' && darkSrc) {
          source.srcset = darkSrc;
        } else if (mode === 'light' && lightSrc) {
          source.srcset = lightSrc;
        }
      });
    }

    // Update images when DOM loads
    document.addEventListener('DOMContentLoaded', updateThemeResponsiveImages);

    // Update images when theme changes
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'data-color-mode') {
          updateThemeResponsiveImages();
        }
      });
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['data-color-mode']
    });

    // Also listen for storage events (cross-tab sync)
    window.addEventListener('storage', function(e) {
      if (e.key === 'citadel-theme-mode') {
        setTimeout(updateThemeResponsiveImages, 10);
      }
    });
  })();

  // Scroll overlay show/hide for sidebar & main content
  (function(){
    const targets=[document.getElementById('sidebar-scroll'), document.getElementById('main-scroll')].filter(Boolean);
    targets.forEach(el=>{
      let to; const activate=()=>{el.classList.add('scrolling'); if(to) clearTimeout(to); to=setTimeout(()=>el.classList.remove('scrolling'),700);};
      el.addEventListener('scroll',activate,{passive:true});
    });
  })();

  // Update TOC sticky offset to match dynamic main header height
  (function(){
    const root=document.documentElement;
    function setOffset(){
      const header=document.querySelector('.main-header');
      if(!header) return;
      const h = Math.ceil(header.getBoundingClientRect().height);
      root.style.setProperty('--citadel-header-offset', h + 'px');
    }
    window.addEventListener('load', setOffset);
    window.addEventListener('resize', setOffset, {passive:true});
    const ro = window.ResizeObserver ? new ResizeObserver(()=>setOffset()) : null;
    if(ro){ const header=document.querySelector('.main-header'); if(header) ro.observe(header); }
  })();

  // TOC flydown: build from on-page TOC and toggle in narrow mode
  (function(){
    const BREAKPOINT = 1280; // px, used for responsive TOC flydown
    const btn = document.getElementById('toc-toggle');
    const fly = document.getElementById('toc-flydown');
    if(!btn || !fly) return;
    const panel = fly.querySelector('.panel');
    function build(){
      const tocInline = document.querySelector('.markdown-body .toc');
      if(!tocInline) return;

      panel.innerHTML = '';
      // Create a wrapper with same class to apply indentation styles
      const wrapper = document.createElement('div');
      wrapper.className = 'toc cloned';
      // Find the inner list container (previously .f6) for compact typography
      const inner = tocInline.querySelector('.f6');
      const cloneSource = inner || tocInline;
      const clone = cloneSource.cloneNode(true);

      // Remove series navigation from flydown and only show generated TOC
      const seriesNav = clone.querySelector('.series-mobile-nav');
      if(seriesNav) {
        seriesNav.remove();
      }

      // Only keep the generated TOC in the flydown
      const generatedToc = clone.querySelector('.generated-toc');
      if(generatedToc) {
        // If there's a generated TOC, make it the main content
        clone.innerHTML = '';
        clone.appendChild(generatedToc);
      }

      wrapper.appendChild(clone);
      panel.appendChild(wrapper);
    }
    let autoHideTimer = null;
    function setOpen(open){
      fly.classList.toggle('is-open', open);
      btn.setAttribute('aria-expanded', open? 'true':'false');
      fly.setAttribute('aria-hidden', open? 'false':'true');
      // Clear any existing auto-hide timer when manually opening/closing
      if(autoHideTimer) {
        clearTimeout(autoHideTimer);
        autoHideTimer = null;
      }
    }
    function scheduleAutoHide(delay = 2000) {
      if(autoHideTimer) clearTimeout(autoHideTimer);
      autoHideTimer = setTimeout(() => {
        if(window.innerWidth < BREAKPOINT && fly.classList.contains('is-open')) {
          // Smooth fade out before closing
          fly.classList.add('fading-out');
          setTimeout(() => {
            setOpen(false);
            fly.classList.remove('fading-out');
          }, 400); // Wait for fade out to complete
        }
        autoHideTimer = null;
      }, delay);
    }
    btn.addEventListener('click', ()=>{
      if(!panel.innerHTML) build();
      setOpen(!fly.classList.contains('is-open'));
    });

    // Handle series navigation clicks - set flag for next page
    document.addEventListener('click', (e) => {
      const seriesBtn = e.target.closest('.series-btn');
      if(seriesBtn && fly.classList.contains('is-open') && window.innerWidth < BREAKPOINT) {
        // Smooth fade out on navigation
        fly.classList.add('fading-out');
        // Set sessionStorage flag that next page should reopen flydown
        sessionStorage.setItem('reopenFlydown', 'true');
      }
    });

    // Handle link clicks inside the panel (narrow mode)
    fly.addEventListener('click', (e)=>{
      const a = e.target.closest('a');
      if(!a || window.innerWidth >= BREAKPOINT) return;

      // Check if this is a series navigation link (next/prev)
      const isSeriesNav = a.closest('.series-btn') || a.closest('.series-mobile-nav');

      if(isSeriesNav) {
        // Smooth fade out and set flag for next page to reopen flydown
        fly.classList.add('fading-out');
        sessionStorage.setItem('reopenFlydown', 'true');
      } else {
        // For regular TOC links, close immediately
        setOpen(false);
      }
    });

    // Check on page load if we should reopen flydown
    if(sessionStorage.getItem('reopenFlydown') === 'true') {
      sessionStorage.removeItem('reopenFlydown');
      if(window.innerWidth < BREAKPOINT) {
        // Small delay to let page settle, then smooth fade in
        setTimeout(() => {
          if(!panel.innerHTML) build();
          setOpen(true);
          scheduleAutoHide();
        }, 200);
      }
    }
    document.addEventListener('click', (e)=>{
      if(window.innerWidth >= BREAKPOINT) return; // only act in narrow mode
      if(!fly.classList.contains('is-open')) return;
      if(fly.contains(e.target) || btn.contains(e.target)) return;
      setOpen(false);
    });
    window.addEventListener('keydown', (e)=>{
      if(e.key==='Escape' && fly.classList.contains('is-open') && window.innerWidth < BREAKPOINT) setOpen(false);
    });
  })();

  // Image lightbox: click to open; wide=fit margins, narrow=50% native;
  // Mouse: click image to zoom 2× (centred on cursor); drag to pan when zoomed; click at max to reset.
  // Touch: pinch-to-zoom; tap outside image to close.
  (function(){
    const NARROW_BREAKPOINT = 1280; // matches TOC flydown/hamburger breakpoint
    const NARROW_SCALE      = 0.5;
    const ZOOM_STEP         = 2;    // multiplier per click
    const lb      = document.getElementById('image-lightbox');
    if (!lb) return;
    const imgEl   = lb.querySelector('img');
    const wrap    = lb.querySelector('.ilb-wrap');
    const content = lb.querySelector('.ilb-content');
    const caption = lb.querySelector('.ilb-caption');
    const backdrop = lb.querySelector('.ilb-backdrop');

    // ── State ──
    let baseW = 0, baseH = 0, maxScale = 1, displayScale = 1;
    let clickFracX = 0.5, clickFracY = 0.5; // fraction within source image at open-click
    let pinching = false, pinchStartDist = 0, pinchStartScale = 1;
    let dragging = false, dragStartX = 0, dragStartY = 0,
        dragScrollL = 0, dragScrollT = 0, dragMoved = false;

    // ── Zoom ──
    // Resize image to baseW/baseH * newScale, keeping anchorFrac* at the same
    // visual position within the content viewport.
    function setScale(newScale, anchorFracX, anchorFracY) {
      newScale = Math.max(1, Math.min(maxScale, newScale));
      const oldW = imgEl.offsetWidth  || baseW * displayScale;
      const oldH = imgEl.offsetHeight || baseH * displayScale;
      const newW = Math.round(baseW * newScale);
      const newH = Math.round(baseH * newScale);
      // Visual position of anchor in the content viewport before resize
      const aFX = (anchorFracX !== undefined) ? anchorFracX : 0.5;
      const aFY = (anchorFracY !== undefined) ? anchorFracY : 0.5;
      const visX = aFX * oldW - content.scrollLeft;
      const visY = aFY * oldH - content.scrollTop;
      displayScale = newScale;
      imgEl.style.width  = newW + 'px';
      imgEl.style.height = newH + 'px';
      requestAnimationFrame(() => {
        const maxSL = Math.max(0, newW - content.offsetWidth);
        const maxST = Math.max(0, newH - content.offsetHeight);
        content.scrollLeft = Math.max(0, Math.min(maxSL, aFX * newW - visX));
        content.scrollTop  = Math.max(0, Math.min(maxST, aFY * newH - visY));
        updateCursor();
      });
    }

    function updateCursor() {
      if (!imgEl) return;
      imgEl.style.cursor = displayScale >= maxScale ? 'zoom-out' :
                           (dragging ? 'grabbing' :
                           (displayScale > 1 ? 'grab' : 'zoom-in'));
    }

    // ── Source selection ──
    function getBestSrc(img) {
      let src = img.currentSrc || img.src;
      const srcset = img.getAttribute('srcset');
      if (srcset) {
        try {
          const best = srcset.split(',').map(s => s.trim()).map(item => {
            const parts = item.split(' ');
            const w = parts.find(p => p.endsWith('w'));
            return { url: parts[0], width: w ? parseInt(w, 10) : 0 };
          }).sort((a, b) => b.width - a.width)[0];
          if (best && best.url) src = best.url;
        } catch(e) {}
      }
      return src;
    }

    // ── Open / close ──
    function computeBase(natW, natH) {
      if (window.innerWidth > NARROW_BREAKPOINT) {
        // Always fill the available width (94% of viewport), scale height proportionally.
        // If that would make the image taller than 92% of the viewport, constrain by height instead.
        const maxW = Math.round(window.innerWidth  * 0.94);
        const maxH = Math.round(window.innerHeight * 0.92);
        const sByW = maxW / natW;
        const sByH = maxH / natH;
        const s = Math.min(sByW, sByH); // fill width unless height would clip
        baseW = Math.round(natW * s);
        baseH = Math.round(natH * s);
      } else {
        // 50% of native pixels, but never smaller than what would fill the
        // available viewport width (so low-res images aren't shown tiny on open).
        const maxW = Math.round(window.innerWidth  * 0.94);
        const maxH = Math.round(window.innerHeight * 0.92);
        const sByW = maxW / natW;
        const sByH = maxH / natH;
        const sFill = Math.min(sByW, sByH);       // scale to fill viewport
        const sNarrow = NARROW_SCALE;              // 50% of native
        const s = Math.max(sNarrow, Math.min(sFill, 1)); // fill viewport, cap at 1× native
        baseW = Math.round(natW * s);
        baseH = Math.round(natH * s);
      }
      maxScale = Math.max(1, natW / baseW);
    }

    function applyBase() {
      displayScale = 1;
      imgEl.style.width     = baseW + 'px';
      imgEl.style.height    = baseH + 'px';
      imgEl.style.maxWidth  = 'none';
      imgEl.style.maxHeight = 'none';
      updateCursor();
    }

    function open(src, alt) {
      const probe = new Image();
      probe.onload = () => {
        computeBase(probe.naturalWidth, probe.naturalHeight);
        applyBase();
        imgEl.src = src;
        imgEl.alt = alt || '';
        lb.classList.add('is-open');
        lb.setAttribute('aria-hidden', 'false');
        if (caption) {
          const text = (alt || '').trim();
          caption.textContent = text || '';
          caption.toggleAttribute('hidden', !text);
        }
        // Scroll to centre on the open-click point
        requestAnimationFrame(() => {
          const maxSL = Math.max(0, baseW - content.offsetWidth);
          const maxST = Math.max(0, baseH - content.offsetHeight);
          content.scrollLeft = Math.max(0, Math.min(maxSL, baseW * clickFracX - content.offsetWidth  / 2));
          content.scrollTop  = Math.max(0, Math.min(maxST, baseH * clickFracY - content.offsetHeight / 2));
        });
      };
      probe.src = src;
    }

    function close() {
      lb.classList.remove('is-open');
      lb.setAttribute('aria-hidden', 'true');
      imgEl.removeAttribute('src');
      imgEl.style.width = imgEl.style.height = '';
      imgEl.style.maxWidth = imgEl.style.maxHeight = imgEl.style.cursor = '';
      displayScale = 1;
      if (caption) { caption.textContent = ''; caption.setAttribute('hidden', ''); }
    }

    // ── Close triggers ──
    backdrop.addEventListener('click', e => { e.stopPropagation(); close(); });
    window.addEventListener('keydown', e => {
      if (e.key === 'Escape' && lb.classList.contains('is-open')) close();
    });
    content.addEventListener('click', e => { if (e.target === content) close(); });
    lb.addEventListener('click',      e => { if (e.target === lb)      close(); });
    lb.addEventListener('touchend', e => {
      if (pinching) return;
      if (e.target === lb || e.target === backdrop || e.target === content) close();
    }, { passive: true });

    // ── Mouse: drag-to-pan + click-to-zoom ──
    if (imgEl) {
      imgEl.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        dragging    = true;
        dragMoved   = false;
        dragStartX  = e.clientX;
        dragStartY  = e.clientY;
        dragScrollL = content.scrollLeft;
        dragScrollT = content.scrollTop;
        imgEl.style.cursor = 'grabbing';
        e.preventDefault();
      });

      window.addEventListener('mousemove', e => {
        if (!dragging) return;
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        if (!dragMoved && (Math.abs(dx) > 4 || Math.abs(dy) > 4)) dragMoved = true;
        if (dragMoved) {
          const maxSL = Math.max(0, imgEl.offsetWidth  - content.offsetWidth);
          const maxST = Math.max(0, imgEl.offsetHeight - content.offsetHeight);
          content.scrollLeft = Math.max(0, Math.min(maxSL, dragScrollL - dx));
          content.scrollTop  = Math.max(0, Math.min(maxST, dragScrollT - dy));
        }
      });

      window.addEventListener('mouseup', e => {
        if (!dragging) return;
        const wasDrag = dragMoved;
        dragging = dragMoved = false;
        if (!wasDrag) {
          // Click: zoom 2× centred on cursor, or reset if at max
          const rect   = imgEl.getBoundingClientRect();
          const fracX  = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
          const fracY  = Math.max(0, Math.min(1, (e.clientY - rect.top)  / rect.height));
          const next   = displayScale >= maxScale ? 1 : displayScale * ZOOM_STEP;
          setScale(next, fracX, fracY);
        } else {
          updateCursor();
        }
      });
    }

    // ── Touch: pinch-to-zoom ──
    function pinchDist(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    if (content) {
      content.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
          pinching = true;
          lb.dataset.pinching = '1';
          pinchStartDist  = pinchDist(e.touches);
          pinchStartScale = displayScale;
          const mx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          const my = (e.touches[0].clientY + e.touches[1].clientY) / 2;
          const rect = imgEl.getBoundingClientRect();
          content.dataset.pinchFracX = Math.max(0, Math.min(1, (mx - rect.left) / rect.width));
          content.dataset.pinchFracY = Math.max(0, Math.min(1, (my - rect.top)  / rect.height));
          e.preventDefault();
        }
      }, { passive: false });

      content.addEventListener('touchmove', e => {
        if (e.touches.length === 2 && pinching) {
          setScale(
            pinchStartScale * (pinchDist(e.touches) / pinchStartDist),
            parseFloat(content.dataset.pinchFracX) || 0.5,
            parseFloat(content.dataset.pinchFracY) || 0.5
          );
          e.preventDefault();
        }
      }, { passive: false });

      content.addEventListener('touchend', e => {
        if (e.touches.length < 2) {
          setTimeout(() => { pinching = false; delete lb.dataset.pinching; }, 150);
        }
      }, { passive: true });
    }

    // ── Open on image click from page ──
    const main = document.getElementById('main-scroll');
    if (main) {
      main.addEventListener('click', e => {
        if (lb.classList.contains('is-open')) return;
        const a = e.target.closest('a');
        if (a && a.contains(e.target)) return;
        const img = e.target.closest('img');
        if (!img) return;
        if (img.src.includes('github.githubassets.com/images/icons/emoji')) return;
        const rect = img.getBoundingClientRect();
        clickFracX = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        clickFracY = Math.max(0, Math.min(1, (e.clientY - rect.top)  / rect.height));
        open(getBestSrc(img), img.alt || '');
      });
    }
  })();

  // Function to switch mode and scroll to header
  window.switchToModeAndScroll = function(modeTitle, headerId) {
    // Find and click the correct mode tab
    const tabs = document.querySelectorAll('[data-modes] .ac-tab');
    const targetTab = Array.from(tabs).find(tab => tab.textContent.trim() === modeTitle);

    if(targetTab) {
      targetTab.click();
      // Wait a moment for the panel to become visible, then scroll
      setTimeout(() => {
        const targetHeader = document.getElementById(headerId);
        if(targetHeader) {
          targetHeader.scrollIntoView({behavior: 'smooth'});
        }
      }, 100);
    }
  };

  // Dynamic TOC: regenerate table of contents to include headers from shared content
  (function(){
    const tocContainer = document.getElementById('dynamic-toc');
    if(!tocContainer) {
      console.log('ERROR: dynamic-toc container not found!');
      return;
    }
    console.log('Found dynamic-toc container:', tocContainer);

    function generateTOC() {
      console.log('Generating TOC...');
      // Find all headers in the main content area
      const contentArea = document.querySelector('.markdown-body .flex-1');
      if(!contentArea) {
        console.log('ERROR: content area not found!');
        return;
      }
      console.log('Found content area:', contentArea);

      // Get all headers, but exclude those in inactive mode panels
      let headers = Array.from(contentArea.querySelectorAll('h2, h3, h4, h5, h6')).filter(header => {
        // Exclude TOC-related headers
        if(header.id === 'in-this-article') return false;
        if(header.textContent.trim() === 'Table of Contents') return false;

        // Exclude headers inside the TOC container itself
        if(header.closest('.toc')) return false;

        // Exclude headers inside series tiles (box elements)
        if(header.closest('.box')) return false;

        // Check if header is inside a mode panel
        const modePanel = header.closest('[data-mode-panel]');
        if(modePanel) {
          // Only include if the mode panel is visible (active)
          return modePanel.style.display !== 'none';
        }
        // Include headers outside of mode panels
        return true;
      });

      if(headers.length === 0) return;

      // First pass: Ensure all headers have proper unique IDs (regenerate every time)
      headers.forEach((header, index) => {
        const text = header.textContent.trim();
        let baseId = text.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '') || `heading-${index}`;

        // Check if header is in a mode panel and make ID unique
        const modePanel = header.closest('[data-mode-panel]');
        if(modePanel) {
          const modeTitle = modePanel.getAttribute('data-title') || 'mode';
          const modePrefix = modeTitle.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-');
          const newId = `${modePrefix}-${baseId}`;
          if(header.id !== newId) {
            header.id = newId;
            console.log(`Set ID for mode header: ${header.id} (mode: ${modeTitle})`);
          }
        } else {
          if(header.id !== baseId) {
            header.id = baseId;
            console.log(`Set ID for regular header: ${header.id}`);
          }
        }
      });

      // Normalize levels for series pages to avoid double indentation
      // If we have multiple H2s after a "Content" H2, treat subsequent H2s as H3s
      let hasContentHeader = false;
      const normalizedHeaders = headers.map(header => {
        const level = parseInt(header.tagName.charAt(1));
        const text = header.textContent.trim();

        if(level === 2 && text.toLowerCase() === 'content') {
          hasContentHeader = true;
          return { header, level, text };
        } else if(hasContentHeader && level === 2 && text.toLowerCase() !== 'content') {
          // Convert subsequent H2s to H3 level for TOC purposes
          return { header, level: 3, text };
        } else {
          return { header, level, text };
        }
      });

      // Build TOC HTML
      let tocHTML = '<nav role="navigation">';
      let currentLevel = 0;
      let firstHeader = true;

      normalizedHeaders.forEach(({header, level, text}, index) => {
        const id = header.id; // ID is now guaranteed to exist

        // Handle nesting levels
        if(firstHeader) {
          tocHTML += '<ul>';
          currentLevel = level;
          firstHeader = false;
        } else if(level > currentLevel) {
          for(let i = currentLevel; i < level; i++) {
            tocHTML += '<ul>';
          }
        } else if(level < currentLevel) {
          for(let i = level; i < currentLevel; i++) {
            tocHTML += '</ul>';
          }
        }

        // Check if header is in a mode panel and add special click handler
        const modePanel = header.closest('[data-mode-panel]');
        const modeTitle = modePanel ? modePanel.getAttribute('data-title') : null;

        if(modeTitle) {
          tocHTML += `<li><a href="#${id}" onclick="switchToModeAndScroll('${modeTitle}', '${id}'); return false;">${text}</a></li>`;
        } else {
          tocHTML += `<li><a href="#${id}">${text}</a></li>`;
        }
        currentLevel = level;
      });

      // Close remaining ul tags
      for(let i = 1; i < currentLevel; i++) {
        tocHTML += '</ul>';
      }
      if(!firstHeader) {
        tocHTML += '</ul>';
      }
      tocHTML += '</nav>';

      // Preserve series navigation but clear everything else
      const seriesNav = tocContainer.querySelector('.series-mobile-nav');
      const seriesNavHTML = seriesNav ? seriesNav.outerHTML : '';

      // Clear the entire TOC container
      tocContainer.innerHTML = '';

      // Restore series navigation if it existed
      if(seriesNavHTML) {
        tocContainer.innerHTML = seriesNavHTML;
      }

      // Add our generated TOC
      const wrapper = document.createElement('div');
      wrapper.className = 'generated-toc';
      wrapper.innerHTML = tocHTML;
      tocContainer.appendChild(wrapper);

      console.log('Added generated TOC with', headers.length, 'headers');
    }

    // Generate TOC after page load and when content changes
    if(document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', generateTOC);
    } else {
      generateTOC();
    }

    // Also regenerate after a short delay to catch any async content loading
    setTimeout(generateTOC, 100);

    // Regenerate TOC when mode tabs are clicked - use more specific detection
    document.addEventListener('click', function(e) {
      // Check if clicked element is a mode tab
      if(e.target.classList.contains('ac-tab') && e.target.closest('.ac-modes')) {
        console.log('Mode tab clicked, regenerating TOC...', e.target.textContent);
        setTimeout(generateTOC, 100);
      }
    });

    // Set up observer after a delay to ensure mode panels are ready
    setTimeout(() => {
      const observer = new MutationObserver(function(mutations) {
        let shouldRegenerate = false;
        mutations.forEach(function(mutation) {
          if(mutation.type === 'attributes' && mutation.attributeName === 'style') {
            const target = mutation.target;
            if(target.hasAttribute('data-mode-panel')) {
              console.log('Mode panel visibility changed:', target.getAttribute('data-title'));
              shouldRegenerate = true;
            }
          }
        });
        if(shouldRegenerate) {
          setTimeout(generateTOC, 100);
        }
      });

      // Observe all mode panels
      const modePanels = document.querySelectorAll('[data-mode-panel]');
      console.log('Setting up observers for', modePanels.length, 'mode panels');
      modePanels.forEach(panel => {
        observer.observe(panel, { attributes: true, attributeFilter: ['style'] });
      });
    }, 200);

    // Expose generateTOC globally for manual regeneration
    window.regenerateTOC = generateTOC;
  })();

  // Scroll position storage is handled specifically by details shortcode only
  // Global scroll restoration has been disabled to prevent unwanted scroll behavior
</script>

{{- block "embedded-script" . }}{{- end }}

</html>