<html data-color-mode="auto" data-light-theme="light" data-dark-theme="dark_dimmed" prefix="og: http://ogp.me/ns#"
  lang="{{ .Language }}">

{{- partial "head.html" . -}}

<body class="width-full overflow-hidden" style="height:100vh;">
  <main class="d-flex flex-row width-full" style="height:100%; min-height:0;">
    {{- partial "sidebar.html" . -}}
  <div id="sidebar-overlay" class="sidebar-overlay"></div>

  <div class="d-flex flex-column flex-1 width-full overflow-y-auto sidebar-scroll scroll-overlay" id="main-scroll" style="min-height:0;">
      <header class="main-header container-xl px-3 px-md-6 width-full" role="banner" aria-label="Main header">
        <div class="d-flex flex-items-center" style="gap:.75rem;">
          {{- partial "breadcrumbs.html" . -}}
          <div class="header-actions">
            {{/* Series neighbors for header controls */}}
            {{ if isset .Params "series" }}
              {{ $seriesTitle := index .Params.series 0 }}
              {{ $currentLink := .Permalink }}
              {{ $wholeSeries := (index .Site.Taxonomies.series ($seriesTitle | urlize)).Pages.ByWeight }}
              {{ range $index, $page := $wholeSeries }}
                {{ if eq $currentLink $page.Permalink }}
                  {{ if gt $index 0 }}
                    {{ .Scratch.Set "prevInSeriesHeader" (index $wholeSeries (sub $index 1)) }}
                  {{ end }}
                  {{ if lt $index (sub (len $wholeSeries) 1) }}
                    {{ .Scratch.Set "nextInSeriesHeader" (index $wholeSeries (add $index 1)) }}
                  {{ end }}
                {{ end }}
              {{ end }}
            {{ end }}
            {{ with index .Scratch.Values "prevInSeriesHeader" }}
              <a class="btn-octicon series-btn" href="{{ .Permalink }}" aria-label="Previous in series: {{ .Title }}" title="{{ .Title }}">{{- partial "octicon" (dict "icon" "chevron-left" "height" 16) -}}</a>
            {{ else }}
              <span class="btn-octicon series-btn is-disabled" aria-disabled="true" title="No previous page">{{- partial "octicon" (dict "icon" "chevron-left" "height" 16) -}}</span>
            {{ end }}
            <button id="toc-toggle" class="btn-octicon toc-btn" type="button" aria-expanded="false" aria-controls="toc-flydown" title="Table of contents">TOC</button>
            {{ with index .Scratch.Values "nextInSeriesHeader" }}
              <a class="btn-octicon series-btn" href="{{ .Permalink }}" aria-label="Next in series: {{ .Title }}" title="{{ .Title }}">{{- partial "octicon" (dict "icon" "chevron-right" "height" 16) -}}</a>
            {{ else }}
              <span class="btn-octicon series-btn is-disabled" aria-disabled="true" title="No next page">{{- partial "octicon" (dict "icon" "chevron-right" "height" 16) -}}</span>
            {{ end }}
          </div>
        </div>
      </header>
      <div id="toc-flydown" aria-hidden="true"><div class="panel container-xl px-3 px-md-6 py-2"></div></div>
      <!-- Image Lightbox Overlay -->
      <div id="image-lightbox" aria-hidden="true">
        <div class="ilb-backdrop" role="presentation"></div>
        <figure class="ilb-content" role="dialog" aria-modal="true" aria-label="Image preview">
          <div class="ilb-wrap">
            <img alt="" />
            <div class="ilb-caption" hidden></div>
          </div>
        </figure>
      </div>
      {{- block "main" . }}{{- end }}
    </div>
  </main>

</body>

<script>
  (function(){
    const STORAGE_KEY='citadel-theme-mode'; // persisted user choice
    const root=document.documentElement;
    function systemPref(){ return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark':'light'; }
    function stored(){ try{return localStorage.getItem(STORAGE_KEY);}catch(e){return null;} }
    function persist(v){ try{ localStorage.setItem(STORAGE_KEY,v);}catch(e){} }
    function apply(mode){
      const eff = mode==='dark' ? 'dark' : 'light';
      root.setAttribute('data-color-mode', eff);
      root.setAttribute('data-light-theme','light');
      root.setAttribute('data-dark-theme','dark_dimmed');
      root.classList.toggle('citadel-user-dark', eff==='dark');
      root.classList.toggle('citadel-user-light', eff==='light');
      updateButtons(eff);

      // Update theme-responsive images immediately
      const images = document.querySelectorAll('img[data-theme-responsive="true"]');
      images.forEach(img => {
        const lightSrc = img.getAttribute('data-light-src');
        const darkSrc = img.getAttribute('data-dark-src');
        if (eff === 'dark' && darkSrc) {
          img.src = darkSrc;
        } else if (eff === 'light' && lightSrc) {
          img.src = lightSrc;
        }
      });
    }
    function updateButtons(eff){
      const lightBtn=document.getElementById('theme-light');
      const darkBtn=document.getElementById('theme-dark');
      if(lightBtn){ lightBtn.classList.toggle('is-active', eff==='light'); lightBtn.setAttribute('aria-pressed', eff==='light'); }
      if(darkBtn){ darkBtn.classList.toggle('is-active', eff==='dark'); darkBtn.setAttribute('aria-pressed', eff==='dark'); }
    }
    document.addEventListener('DOMContentLoaded',function(){
      apply(stored()||systemPref());
      const btnLight=document.getElementById('theme-light');
      const btnDark=document.getElementById('theme-dark');
      if(btnLight) btnLight.addEventListener('click',()=>{ persist('light'); apply('light'); });
      if(btnDark) btnDark.addEventListener('click',()=>{ persist('dark'); apply('dark'); });
      if(window.matchMedia){
        const mq=window.matchMedia('(prefers-color-scheme: dark)');
        mq.addEventListener('change',()=>{ if(!stored()){ apply(systemPref()); } });
      }
      window.addEventListener('storage',e=>{ if(e.key===STORAGE_KEY) apply(stored()||systemPref()); });
    });
    // Fallback: delegate clicks in case DOMContentLoaded timing prevented binding
    document.addEventListener('click', function(e){
      const light = e.target.closest && e.target.closest('#theme-light');
      const dark = e.target.closest && e.target.closest('#theme-dark');
      if(light){ persist('light'); apply('light'); }
      else if(dark){ persist('dark'); apply('dark'); }
    });
  })();

  // GitHub-style theme-responsive images
  (function(){
    function updateThemeResponsiveImages() {
      const mode = document.documentElement.getAttribute('data-color-mode') || 'light';
      const images = document.querySelectorAll('img[data-theme-responsive="true"]');

      images.forEach(img => {
        const lightSrc = img.getAttribute('data-light-src');
        const darkSrc = img.getAttribute('data-dark-src');

        if (mode === 'dark' && darkSrc) {
          img.src = darkSrc;
        } else if (mode === 'light' && lightSrc) {
          img.src = lightSrc;
        }
      });

      // Also update source elements in picture tags
      const sources = document.querySelectorAll('source[data-light-src], source[data-dark-src]');
      sources.forEach(source => {
        const lightSrc = source.getAttribute('data-light-src');
        const darkSrc = source.getAttribute('data-dark-src');

        if (mode === 'dark' && darkSrc) {
          source.srcset = darkSrc;
        } else if (mode === 'light' && lightSrc) {
          source.srcset = lightSrc;
        }
      });
    }

    // Update images when DOM loads
    document.addEventListener('DOMContentLoaded', updateThemeResponsiveImages);

    // Update images when theme changes
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'data-color-mode') {
          updateThemeResponsiveImages();
        }
      });
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['data-color-mode']
    });

    // Also listen for storage events (cross-tab sync)
    window.addEventListener('storage', function(e) {
      if (e.key === 'citadel-theme-mode') {
        setTimeout(updateThemeResponsiveImages, 10);
      }
    });
  })();

  // Scroll overlay show/hide for sidebar & main content
  (function(){
    const targets=[document.getElementById('sidebar-scroll'), document.getElementById('main-scroll')].filter(Boolean);
    targets.forEach(el=>{
      let to; const activate=()=>{el.classList.add('scrolling'); if(to) clearTimeout(to); to=setTimeout(()=>el.classList.remove('scrolling'),700);};
      el.addEventListener('scroll',activate,{passive:true});
    });
  })();

  // Update TOC sticky offset to match dynamic main header height
  (function(){
    const root=document.documentElement;
    function setOffset(){
      const header=document.querySelector('.main-header');
      if(!header) return;
      const h = Math.ceil(header.getBoundingClientRect().height);
      root.style.setProperty('--citadel-header-offset', h + 'px');
    }
    window.addEventListener('load', setOffset);
    window.addEventListener('resize', setOffset, {passive:true});
    const ro = window.ResizeObserver ? new ResizeObserver(()=>setOffset()) : null;
    if(ro){ const header=document.querySelector('.main-header'); if(header) ro.observe(header); }
  })();

  // TOC flydown: build from on-page TOC and toggle in narrow mode
  (function(){
    const BREAKPOINT = 1280; // px, used for responsive TOC flydown
    const btn = document.getElementById('toc-toggle');
    const fly = document.getElementById('toc-flydown');
    if(!btn || !fly) return;
    const panel = fly.querySelector('.panel');
    function build(){
      const tocInline = document.querySelector('.markdown-body .toc');
      if(!tocInline) return;
      panel.innerHTML = '';
      // Create a wrapper with same class to apply indentation styles
      const wrapper = document.createElement('div');
      wrapper.className = 'toc cloned';
      // Find the inner list container (previously .f6) for compact typography
      const inner = tocInline.querySelector('.f6');
      const cloneSource = inner || tocInline;
      const clone = cloneSource.cloneNode(true);
      wrapper.appendChild(clone);
      panel.appendChild(wrapper);
    }
    function setOpen(open){
      fly.classList.toggle('is-open', open);
      btn.setAttribute('aria-expanded', open? 'true':'false');
      fly.setAttribute('aria-hidden', open? 'false':'true');
    }
    btn.addEventListener('click', ()=>{
      if(!panel.innerHTML) build();
      setOpen(!fly.classList.contains('is-open'));
    });
    // Close on link click inside the panel (narrow mode)
    fly.addEventListener('click', (e)=>{
      const a = e.target.closest('a');
      if(!a) return;
      if(window.innerWidth < BREAKPOINT) setOpen(false);
    });
    document.addEventListener('click', (e)=>{
      if(window.innerWidth >= BREAKPOINT) return; // only act in narrow mode
      if(!fly.classList.contains('is-open')) return;
      if(fly.contains(e.target) || btn.contains(e.target)) return;
      setOpen(false);
    });
    window.addEventListener('keydown', (e)=>{
      if(e.key==='Escape' && fly.classList.contains('is-open') && window.innerWidth < BREAKPOINT) setOpen(false);
    });
  })();

  // Image lightbox: click images to open at native size within viewport
  (function(){
    const lb = document.getElementById('image-lightbox');
    if(!lb) return;
  const imgEl = lb.querySelector('img');
  const caption = lb.querySelector('.ilb-caption');
    const backdrop = lb.querySelector('.ilb-backdrop');
    function open(src, alt){
      imgEl.src = src;
      imgEl.alt = alt||'';
      lb.classList.add('is-open');
      lb.setAttribute('aria-hidden','false');
      if(caption){
        const text = (alt||'').trim();
        caption.textContent = text || '';
        caption.toggleAttribute('hidden', !text);
      }
    }
    function close(){
      lb.classList.remove('is-open');
      lb.setAttribute('aria-hidden','true');
  imgEl.removeAttribute('src');
  if(caption){ caption.textContent=''; caption.setAttribute('hidden',''); }
    }
  backdrop.addEventListener('click', (e)=>{ e.stopPropagation(); close(); });
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && lb.classList.contains('is-open')) close(); });
  // Clicking anywhere on the overlay closes it
  lb.addEventListener('click', (e)=>{ e.stopPropagation(); close(); });
    // Delegate clicks on images inside main content
    const main = document.getElementById('main-scroll');
  if(main){
      main.addEventListener('click', (e)=>{
    // Ignore clicks while lightbox is open
    if(lb && lb.classList.contains('is-open')) return;
        const a = e.target.closest('a');
        if(a && a.contains(e.target)) return; // don't override linked images
        const img = e.target.closest('img');
        if(!img) return;
        // ignore emoji/utility images
        if(img.src.includes('github.githubassets.com/images/icons/emoji')) return;
        // choose largest srcset candidate if present
        let src = img.currentSrc || img.src;
        const srcset = img.getAttribute('srcset');
        if(srcset){
          try{
            const candidates = srcset.split(',').map(s=>s.trim()).map(item=>{
              const parts = item.split(' ');
              const url = parts[0];
              const w = parts.find(p=>p.endsWith('w'));
              const width = w ? parseInt(w.replace('w',''),10) : 0;
              return {url, width};
            });
            const best = candidates.sort((a,b)=>b.width-a.width)[0];
            if(best && best.url) src = best.url;
          }catch(err){ /* fall back to currentSrc */ }
        }
        open(src, img.alt || '');
      });
    }
  })();

  // Dynamic TOC: regenerate table of contents to include headers from shared content
  (function(){
    const tocContainer = document.getElementById('dynamic-toc');
    if(!tocContainer) return;

    function generateTOC() {
      // Find all headers in the main content area
      const contentArea = document.querySelector('.markdown-body .flex-1');
      if(!contentArea) return;

      const headers = contentArea.querySelectorAll('h1, h2, h3, h4, h5, h6');
      if(headers.length === 0) return;

      // Build TOC HTML
      let tocHTML = '<nav role="navigation"><ul>';
      let currentLevel = 0;

      headers.forEach((header, index) => {
        const level = parseInt(header.tagName.charAt(1));
        const text = header.textContent.trim();
        const id = header.id || `heading-${index}`;

        // Ensure header has an ID for linking
        if(!header.id) header.id = id;

        // Handle nesting levels
        if(level > currentLevel) {
          for(let i = currentLevel; i < level; i++) {
            if(i > 0) tocHTML += '<ul>';
          }
        } else if(level < currentLevel) {
          for(let i = level; i < currentLevel; i++) {
            tocHTML += '</ul>';
          }
        }

        tocHTML += `<li><a href="#${id}">${text}</a></li>`;
        currentLevel = level;
      });

      // Close remaining ul tags
      for(let i = 0; i < currentLevel; i++) {
        tocHTML += '</ul>';
      }
      tocHTML += '</nav>';

      // Replace or supplement existing TOC
      const existingTOC = tocContainer.querySelector('nav');
      if(existingTOC && headers.length > existingTOC.querySelectorAll('a').length) {
        // More headers found than in existing TOC - replace it
        existingTOC.outerHTML = tocHTML;
      } else if(!existingTOC) {
        // No existing TOC - add the generated one
        tocContainer.innerHTML = tocHTML;
      }
    }

    // Generate TOC after page load and when content changes
    if(document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', generateTOC);
    } else {
      generateTOC();
    }

    // Also regenerate after a short delay to catch any async content loading
    setTimeout(generateTOC, 100);
  })();
</script>

{{- block "embedded-script" . }}{{- end }}

</html>