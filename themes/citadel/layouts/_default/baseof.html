<html data-color-mode="auto" data-light-theme="light" data-dark-theme="dark_dimmed" prefix="og: http://ogp.me/ns#"
  lang="{{ .Language }}">

{{- partial "head.html" . -}}

<body class="width-full overflow-hidden" style="height:100vh;">
  <main class="d-flex flex-row width-full" style="height:100%; min-height:0;">
    {{- partial "sidebar.html" . -}}
  <div id="sidebar-overlay" class="sidebar-overlay"></div>

  <div class="d-flex flex-column flex-1 width-full overflow-y-auto sidebar-scroll scroll-overlay" id="main-scroll" style="min-height:0;">
      <header class="main-header container-xl px-3 px-md-6 width-full" role="banner" aria-label="Main header">
        <div class="d-flex flex-items-center" style="gap:.75rem;">
          {{- partial "breadcrumbs.html" . -}}
          <div class="header-actions">
            {{/* Series neighbors for header controls */}}
            {{- partial "series-navigation.html" . -}}
            {{ with index .Scratch.Values "prevInSeriesHeader" }}
              <a class="btn-octicon series-btn" href="{{ .Permalink }}" aria-label="Previous in series: {{ .Title }}" title="{{ .Title }}">{{- partial "octicon" (dict "icon" "chevron-left" "height" 16) -}}</a>
            {{ else }}
              <span class="btn-octicon series-btn is-disabled" aria-disabled="true" title="No previous page">{{- partial "octicon" (dict "icon" "chevron-left" "height" 16) -}}</span>
            {{ end }}
            <button id="toc-toggle" class="btn-octicon toc-btn" type="button" aria-expanded="false" aria-controls="toc-flydown" title="Table of contents">TOC</button>
            {{ with index .Scratch.Values "nextInSeriesHeader" }}
              <a class="btn-octicon series-btn" href="{{ .Permalink }}" aria-label="Next in series: {{ .Title }}" title="{{ .Title }}">{{- partial "octicon" (dict "icon" "chevron-right" "height" 16) -}}</a>
            {{ else }}
              <span class="btn-octicon series-btn is-disabled" aria-disabled="true" title="No next page">{{- partial "octicon" (dict "icon" "chevron-right" "height" 16) -}}</span>
            {{ end }}
          </div>
        </div>
      </header>
      <div id="toc-flydown" aria-hidden="true"><div class="panel container-xl px-3 px-md-6 py-2"></div></div>
      <!-- Image Lightbox Overlay -->
      <div id="image-lightbox" aria-hidden="true">
        <div class="ilb-backdrop" role="presentation"></div>
        <figure class="ilb-content" role="dialog" aria-modal="true" aria-label="Image preview">
          <div class="ilb-wrap">
            <img alt="" />
            <div class="ilb-caption" hidden></div>
          </div>
        </figure>
      </div>
      {{- block "main" . }}{{- end }}
    </div>
  </main>

</body>

<script>
  (function(){
    const STORAGE_KEY='citadel-theme-mode'; // persisted user choice
    const root=document.documentElement;
    function systemPref(){ return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark':'light'; }
    function stored(){ try{return localStorage.getItem(STORAGE_KEY);}catch(e){return null;} }
    function persist(v){ try{ localStorage.setItem(STORAGE_KEY,v);}catch(e){} }
    function apply(mode){
      const eff = mode==='dark' ? 'dark' : 'light';
      root.setAttribute('data-color-mode', eff);
      root.setAttribute('data-light-theme','light');
      root.setAttribute('data-dark-theme','dark_dimmed');
      root.classList.toggle('citadel-user-dark', eff==='dark');
      root.classList.toggle('citadel-user-light', eff==='light');
      updateButtons(eff);

      // Update theme-responsive images immediately
      const images = document.querySelectorAll('img[data-theme-responsive="true"]');
      images.forEach(img => {
        const lightSrc = img.getAttribute('data-light-src');
        const darkSrc = img.getAttribute('data-dark-src');
        if (eff === 'dark' && darkSrc) {
          img.src = darkSrc;
        } else if (eff === 'light' && lightSrc) {
          img.src = lightSrc;
        }
      });
    }
    function updateButtons(eff){
      const lightBtn=document.getElementById('theme-light');
      const darkBtn=document.getElementById('theme-dark');
      if(lightBtn){ lightBtn.classList.toggle('is-active', eff==='light'); lightBtn.setAttribute('aria-pressed', eff==='light'); }
      if(darkBtn){ darkBtn.classList.toggle('is-active', eff==='dark'); darkBtn.setAttribute('aria-pressed', eff==='dark'); }
    }
    document.addEventListener('DOMContentLoaded',function(){
      apply(stored()||systemPref());
      const btnLight=document.getElementById('theme-light');
      const btnDark=document.getElementById('theme-dark');
      if(btnLight) btnLight.addEventListener('click',()=>{ persist('light'); apply('light'); });
      if(btnDark) btnDark.addEventListener('click',()=>{ persist('dark'); apply('dark'); });
      if(window.matchMedia){
        const mq=window.matchMedia('(prefers-color-scheme: dark)');
        mq.addEventListener('change',()=>{ if(!stored()){ apply(systemPref()); } });
      }
      window.addEventListener('storage',e=>{ if(e.key===STORAGE_KEY) apply(stored()||systemPref()); });
    });
    // Fallback: delegate clicks in case DOMContentLoaded timing prevented binding
    document.addEventListener('click', function(e){
      const light = e.target.closest && e.target.closest('#theme-light');
      const dark = e.target.closest && e.target.closest('#theme-dark');
      if(light){ persist('light'); apply('light'); }
      else if(dark){ persist('dark'); apply('dark'); }
    });
  })();

  // GitHub-style theme-responsive images
  (function(){
    function updateThemeResponsiveImages() {
      const mode = document.documentElement.getAttribute('data-color-mode') || 'light';
      const images = document.querySelectorAll('img[data-theme-responsive="true"]');

      images.forEach(img => {
        const lightSrc = img.getAttribute('data-light-src');
        const darkSrc = img.getAttribute('data-dark-src');

        if (mode === 'dark' && darkSrc) {
          img.src = darkSrc;
        } else if (mode === 'light' && lightSrc) {
          img.src = lightSrc;
        }
      });

      // Also update source elements in picture tags
      const sources = document.querySelectorAll('source[data-light-src], source[data-dark-src]');
      sources.forEach(source => {
        const lightSrc = source.getAttribute('data-light-src');
        const darkSrc = source.getAttribute('data-dark-src');

        if (mode === 'dark' && darkSrc) {
          source.srcset = darkSrc;
        } else if (mode === 'light' && lightSrc) {
          source.srcset = lightSrc;
        }
      });
    }

    // Update images when DOM loads
    document.addEventListener('DOMContentLoaded', updateThemeResponsiveImages);

    // Update images when theme changes
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'data-color-mode') {
          updateThemeResponsiveImages();
        }
      });
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['data-color-mode']
    });

    // Also listen for storage events (cross-tab sync)
    window.addEventListener('storage', function(e) {
      if (e.key === 'citadel-theme-mode') {
        setTimeout(updateThemeResponsiveImages, 10);
      }
    });
  })();

  // Scroll overlay show/hide for sidebar & main content
  (function(){
    const targets=[document.getElementById('sidebar-scroll'), document.getElementById('main-scroll')].filter(Boolean);
    targets.forEach(el=>{
      let to; const activate=()=>{el.classList.add('scrolling'); if(to) clearTimeout(to); to=setTimeout(()=>el.classList.remove('scrolling'),700);};
      el.addEventListener('scroll',activate,{passive:true});
    });
  })();

  // Update TOC sticky offset to match dynamic main header height
  (function(){
    const root=document.documentElement;
    function setOffset(){
      const header=document.querySelector('.main-header');
      if(!header) return;
      const h = Math.ceil(header.getBoundingClientRect().height);
      root.style.setProperty('--citadel-header-offset', h + 'px');
    }
    window.addEventListener('load', setOffset);
    window.addEventListener('resize', setOffset, {passive:true});
    const ro = window.ResizeObserver ? new ResizeObserver(()=>setOffset()) : null;
    if(ro){ const header=document.querySelector('.main-header'); if(header) ro.observe(header); }
  })();

  // TOC flydown: build from on-page TOC and toggle in narrow mode
  (function(){
    const BREAKPOINT = 1280; // px, used for responsive TOC flydown
    const btn = document.getElementById('toc-toggle');
    const fly = document.getElementById('toc-flydown');
    if(!btn || !fly) return;
    const panel = fly.querySelector('.panel');
    function build(){
      const tocInline = document.querySelector('.markdown-body .toc');
      if(!tocInline) return;

      panel.innerHTML = '';
      // Create a wrapper with same class to apply indentation styles
      const wrapper = document.createElement('div');
      wrapper.className = 'toc cloned';
      // Find the inner list container (previously .f6) for compact typography
      const inner = tocInline.querySelector('.f6');
      const cloneSource = inner || tocInline;
      const clone = cloneSource.cloneNode(true);

      // Remove series navigation from flydown and only show generated TOC
      const seriesNav = clone.querySelector('.series-mobile-nav');
      if(seriesNav) {
        seriesNav.remove();
      }

      // Only keep the generated TOC in the flydown
      const generatedToc = clone.querySelector('.generated-toc');
      if(generatedToc) {
        // If there's a generated TOC, make it the main content
        clone.innerHTML = '';
        clone.appendChild(generatedToc);
      }

      wrapper.appendChild(clone);
      panel.appendChild(wrapper);
    }
    let autoHideTimer = null;
    function setOpen(open){
      fly.classList.toggle('is-open', open);
      btn.setAttribute('aria-expanded', open? 'true':'false');
      fly.setAttribute('aria-hidden', open? 'false':'true');
      // Clear any existing auto-hide timer when manually opening/closing
      if(autoHideTimer) {
        clearTimeout(autoHideTimer);
        autoHideTimer = null;
      }
    }
    function scheduleAutoHide(delay = 2000) {
      if(autoHideTimer) clearTimeout(autoHideTimer);
      autoHideTimer = setTimeout(() => {
        if(window.innerWidth < BREAKPOINT && fly.classList.contains('is-open')) {
          // Smooth fade out before closing
          fly.classList.add('fading-out');
          setTimeout(() => {
            setOpen(false);
            fly.classList.remove('fading-out');
          }, 400); // Wait for fade out to complete
        }
        autoHideTimer = null;
      }, delay);
    }
    btn.addEventListener('click', ()=>{
      if(!panel.innerHTML) build();
      setOpen(!fly.classList.contains('is-open'));
    });

    // Handle series navigation clicks - set flag for next page
    document.addEventListener('click', (e) => {
      const seriesBtn = e.target.closest('.series-btn');
      if(seriesBtn && fly.classList.contains('is-open') && window.innerWidth < BREAKPOINT) {
        // Smooth fade out on navigation
        fly.classList.add('fading-out');
        // Set sessionStorage flag that next page should reopen flydown
        sessionStorage.setItem('reopenFlydown', 'true');
      }
    });

    // Handle link clicks inside the panel (narrow mode)
    fly.addEventListener('click', (e)=>{
      const a = e.target.closest('a');
      if(!a || window.innerWidth >= BREAKPOINT) return;

      // Check if this is a series navigation link (next/prev)
      const isSeriesNav = a.closest('.series-btn') || a.closest('.series-mobile-nav');

      if(isSeriesNav) {
        // Smooth fade out and set flag for next page to reopen flydown
        fly.classList.add('fading-out');
        sessionStorage.setItem('reopenFlydown', 'true');
      } else {
        // For regular TOC links, close immediately
        setOpen(false);
      }
    });

    // Check on page load if we should reopen flydown
    if(sessionStorage.getItem('reopenFlydown') === 'true') {
      sessionStorage.removeItem('reopenFlydown');
      if(window.innerWidth < BREAKPOINT) {
        // Small delay to let page settle, then smooth fade in
        setTimeout(() => {
          if(!panel.innerHTML) build();
          setOpen(true);
          scheduleAutoHide();
        }, 200);
      }
    }
    document.addEventListener('click', (e)=>{
      if(window.innerWidth >= BREAKPOINT) return; // only act in narrow mode
      if(!fly.classList.contains('is-open')) return;
      if(fly.contains(e.target) || btn.contains(e.target)) return;
      setOpen(false);
    });
    window.addEventListener('keydown', (e)=>{
      if(e.key==='Escape' && fly.classList.contains('is-open') && window.innerWidth < BREAKPOINT) setOpen(false);
    });
  })();

  // Image lightbox: click images to open at native size within viewport
  (function(){
    const lb = document.getElementById('image-lightbox');
    if(!lb) return;
  const imgEl = lb.querySelector('img');
  const caption = lb.querySelector('.ilb-caption');
    const backdrop = lb.querySelector('.ilb-backdrop');
    function open(src, alt){
      imgEl.src = src;
      imgEl.alt = alt||'';
      lb.classList.add('is-open');
      lb.setAttribute('aria-hidden','false');
      if(caption){
        const text = (alt||'').trim();
        caption.textContent = text || '';
        caption.toggleAttribute('hidden', !text);
      }
    }
    function close(){
      lb.classList.remove('is-open');
      lb.setAttribute('aria-hidden','true');
  imgEl.removeAttribute('src');
  if(caption){ caption.textContent=''; caption.setAttribute('hidden',''); }
    }
  backdrop.addEventListener('click', (e)=>{ e.stopPropagation(); close(); });
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && lb.classList.contains('is-open')) close(); });
  // Clicking anywhere on the overlay closes it
  lb.addEventListener('click', (e)=>{ e.stopPropagation(); close(); });
    // Delegate clicks on images inside main content
    const main = document.getElementById('main-scroll');
  if(main){
      main.addEventListener('click', (e)=>{
    // Ignore clicks while lightbox is open
    if(lb && lb.classList.contains('is-open')) return;
        const a = e.target.closest('a');
        if(a && a.contains(e.target)) return; // don't override linked images
        const img = e.target.closest('img');
        if(!img) return;
        // ignore emoji/utility images
        if(img.src.includes('github.githubassets.com/images/icons/emoji')) return;
        // choose largest srcset candidate if present
        let src = img.currentSrc || img.src;
        const srcset = img.getAttribute('srcset');
        if(srcset){
          try{
            const candidates = srcset.split(',').map(s=>s.trim()).map(item=>{
              const parts = item.split(' ');
              const url = parts[0];
              const w = parts.find(p=>p.endsWith('w'));
              const width = w ? parseInt(w.replace('w',''),10) : 0;
              return {url, width};
            });
            const best = candidates.sort((a,b)=>b.width-a.width)[0];
            if(best && best.url) src = best.url;
          }catch(err){ /* fall back to currentSrc */ }
        }
        open(src, img.alt || '');
      });
    }
  })();

  // Function to switch mode and scroll to header
  window.switchToModeAndScroll = function(modeTitle, headerId) {
    // Find and click the correct mode tab
    const tabs = document.querySelectorAll('[data-modes] .ac-tab');
    const targetTab = Array.from(tabs).find(tab => tab.textContent.trim() === modeTitle);

    if(targetTab) {
      targetTab.click();
      // Wait a moment for the panel to become visible, then scroll
      setTimeout(() => {
        const targetHeader = document.getElementById(headerId);
        if(targetHeader) {
          targetHeader.scrollIntoView({behavior: 'smooth'});
        }
      }, 100);
    }
  };

  // Dynamic TOC: regenerate table of contents to include headers from shared content
  (function(){
    const tocContainer = document.getElementById('dynamic-toc');
    if(!tocContainer) {
      console.log('ERROR: dynamic-toc container not found!');
      return;
    }
    console.log('Found dynamic-toc container:', tocContainer);

    function generateTOC() {
      console.log('Generating TOC...');
      // Find all headers in the main content area
      const contentArea = document.querySelector('.markdown-body .flex-1');
      if(!contentArea) {
        console.log('ERROR: content area not found!');
        return;
      }
      console.log('Found content area:', contentArea);

      // Get all headers, but exclude those in inactive mode panels
      let headers = Array.from(contentArea.querySelectorAll('h2, h3, h4, h5, h6')).filter(header => {
        // Exclude TOC-related headers
        if(header.id === 'in-this-article') return false;
        if(header.textContent.trim() === 'Table of Contents') return false;

        // Exclude headers inside the TOC container itself
        if(header.closest('.toc')) return false;

        // Exclude headers inside series tiles (box elements)
        if(header.closest('.box')) return false;

        // Check if header is inside a mode panel
        const modePanel = header.closest('[data-mode-panel]');
        if(modePanel) {
          // Only include if the mode panel is visible (active)
          return modePanel.style.display !== 'none';
        }
        // Include headers outside of mode panels
        return true;
      });

      if(headers.length === 0) return;

      // First pass: Ensure all headers have proper unique IDs (regenerate every time)
      headers.forEach((header, index) => {
        const text = header.textContent.trim();
        let baseId = text.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '') || `heading-${index}`;

        // Check if header is in a mode panel and make ID unique
        const modePanel = header.closest('[data-mode-panel]');
        if(modePanel) {
          const modeTitle = modePanel.getAttribute('data-title') || 'mode';
          const modePrefix = modeTitle.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-');
          const newId = `${modePrefix}-${baseId}`;
          if(header.id !== newId) {
            header.id = newId;
            console.log(`Set ID for mode header: ${header.id} (mode: ${modeTitle})`);
          }
        } else {
          if(header.id !== baseId) {
            header.id = baseId;
            console.log(`Set ID for regular header: ${header.id}`);
          }
        }
      });

      // Normalize levels for series pages to avoid double indentation
      // If we have multiple H2s after a "Content" H2, treat subsequent H2s as H3s
      let hasContentHeader = false;
      const normalizedHeaders = headers.map(header => {
        const level = parseInt(header.tagName.charAt(1));
        const text = header.textContent.trim();

        if(level === 2 && text.toLowerCase() === 'content') {
          hasContentHeader = true;
          return { header, level, text };
        } else if(hasContentHeader && level === 2 && text.toLowerCase() !== 'content') {
          // Convert subsequent H2s to H3 level for TOC purposes
          return { header, level: 3, text };
        } else {
          return { header, level, text };
        }
      });

      // Build TOC HTML
      let tocHTML = '<nav role="navigation">';
      let currentLevel = 0;
      let firstHeader = true;

      normalizedHeaders.forEach(({header, level, text}, index) => {
        const id = header.id; // ID is now guaranteed to exist

        // Handle nesting levels
        if(firstHeader) {
          tocHTML += '<ul>';
          currentLevel = level;
          firstHeader = false;
        } else if(level > currentLevel) {
          for(let i = currentLevel; i < level; i++) {
            tocHTML += '<ul>';
          }
        } else if(level < currentLevel) {
          for(let i = level; i < currentLevel; i++) {
            tocHTML += '</ul>';
          }
        }

        // Check if header is in a mode panel and add special click handler
        const modePanel = header.closest('[data-mode-panel]');
        const modeTitle = modePanel ? modePanel.getAttribute('data-title') : null;

        if(modeTitle) {
          tocHTML += `<li><a href="#${id}" onclick="switchToModeAndScroll('${modeTitle}', '${id}'); return false;">${text}</a></li>`;
        } else {
          tocHTML += `<li><a href="#${id}">${text}</a></li>`;
        }
        currentLevel = level;
      });

      // Close remaining ul tags
      for(let i = 1; i < currentLevel; i++) {
        tocHTML += '</ul>';
      }
      if(!firstHeader) {
        tocHTML += '</ul>';
      }
      tocHTML += '</nav>';

      // Preserve series navigation but clear everything else
      const seriesNav = tocContainer.querySelector('.series-mobile-nav');
      const seriesNavHTML = seriesNav ? seriesNav.outerHTML : '';

      // Clear the entire TOC container
      tocContainer.innerHTML = '';

      // Restore series navigation if it existed
      if(seriesNavHTML) {
        tocContainer.innerHTML = seriesNavHTML;
      }

      // Add our generated TOC
      const wrapper = document.createElement('div');
      wrapper.className = 'generated-toc';
      wrapper.innerHTML = tocHTML;
      tocContainer.appendChild(wrapper);

      console.log('Added generated TOC with', headers.length, 'headers');
    }

    // Generate TOC after page load and when content changes
    if(document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', generateTOC);
    } else {
      generateTOC();
    }

    // Also regenerate after a short delay to catch any async content loading
    setTimeout(generateTOC, 100);

    // Regenerate TOC when mode tabs are clicked - use more specific detection
    document.addEventListener('click', function(e) {
      // Check if clicked element is a mode tab
      if(e.target.classList.contains('ac-tab') && e.target.closest('.ac-modes')) {
        console.log('Mode tab clicked, regenerating TOC...', e.target.textContent);
        setTimeout(generateTOC, 100);
      }
    });

    // Set up observer after a delay to ensure mode panels are ready
    setTimeout(() => {
      const observer = new MutationObserver(function(mutations) {
        let shouldRegenerate = false;
        mutations.forEach(function(mutation) {
          if(mutation.type === 'attributes' && mutation.attributeName === 'style') {
            const target = mutation.target;
            if(target.hasAttribute('data-mode-panel')) {
              console.log('Mode panel visibility changed:', target.getAttribute('data-title'));
              shouldRegenerate = true;
            }
          }
        });
        if(shouldRegenerate) {
          setTimeout(generateTOC, 100);
        }
      });

      // Observe all mode panels
      const modePanels = document.querySelectorAll('[data-mode-panel]');
      console.log('Setting up observers for', modePanels.length, 'mode panels');
      modePanels.forEach(panel => {
        observer.observe(panel, { attributes: true, attributeFilter: ['style'] });
      });
    }, 200);

    // Expose generateTOC globally for manual regeneration
    window.regenerateTOC = generateTOC;
  })();

  // Custom scroll restoration for #main-scroll container
  (function() {
    const scrollContainer = document.getElementById('main-scroll');
    const SCROLL_KEY = 'citadel-scroll-positions';

    if (!scrollContainer) return;

    // Get stored scroll positions from sessionStorage
    function getStoredPositions() {
      try {
        return JSON.parse(sessionStorage.getItem(SCROLL_KEY)) || {};
      } catch {
        return {};
      }
    }

    // Store current scroll position for this page
    function storeScrollPosition() {
      const positions = getStoredPositions();
      positions[location.pathname] = scrollContainer.scrollTop;
      try {
        sessionStorage.setItem(SCROLL_KEY, JSON.stringify(positions));
      } catch {
        // Handle quota exceeded or other storage errors silently
      }
    }

    // Restore scroll position for this page
    function restoreScrollPosition() {
      const positions = getStoredPositions();
      const savedPosition = positions[location.pathname];

      if (savedPosition && savedPosition > 0) {
        scrollContainer.scrollTop = savedPosition;
      }
    }

    // Store position before leaving the page
    window.addEventListener('beforeunload', storeScrollPosition);

    // Store position when clicking internal links
    document.addEventListener('click', function(e) {
      const link = e.target.closest('a[href]');
      if (link && !link.href.startsWith('mailto:') && !link.href.startsWith('tel:') && !link.target) {
        // Only store for internal navigation, not external links or downloads
        storeScrollPosition();
      }
    });

    // Restore position when page loads (after content is ready)
    function handlePageLoad() {
      // Small delay to ensure content is fully loaded
      setTimeout(restoreScrollPosition, 150);
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', handlePageLoad);
    } else {
      handlePageLoad();
    }

    // Handle browser back/forward navigation
    window.addEventListener('popstate', function() {
      setTimeout(restoreScrollPosition, 150);
    });

    // Clean up old scroll positions (keep only last 50 pages to prevent storage bloat)
    function cleanupOldPositions() {
      const positions = getStoredPositions();
      const entries = Object.entries(positions);
      if (entries.length > 50) {
        const recent = Object.fromEntries(entries.slice(-50));
        try {
          sessionStorage.setItem(SCROLL_KEY, JSON.stringify(recent));
        } catch {
          // Handle storage errors silently
        }
      }
    }

    // Periodically clean up storage
    setTimeout(cleanupOldPositions, 1000);
  })();
</script>

{{- block "embedded-script" . }}{{- end }}

</html>